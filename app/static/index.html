<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Note Nomi</title>
    <style>
      :root { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
      body { margin: 0; background: #f6f7fb; color: #1d1f2a; }
      .container { max-width: 960px; margin: 0 auto; padding: 24px 16px 40px; }
      .card { background: #fff; border-radius: 12px; box-shadow: 0 2px 10px rgba(17, 24, 39, 0.08); padding: 16px; margin-bottom: 16px; }
      h1, h2 { margin-top: 0; }
      form { display: grid; gap: 12px; }
      input, textarea, button { font: inherit; }
      input, textarea { width: 100%; box-sizing: border-box; border: 1px solid #d4d7e3; border-radius: 8px; padding: 10px 12px; }
      button { background: #3f5efb; color: #fff; border: 0; border-radius: 8px; padding: 10px 14px; cursor: pointer; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      .note { border: 1px solid #e6e8f2; border-radius: 10px; padding: 12px; margin-top: 10px; cursor: pointer; }
      .note:hover { border-color: #3f5efb; background: #f8f9ff; }
      .muted { color: #61657a; font-size: 0.9rem; }
      .tags { display: flex; flex-wrap: wrap; gap: 6px; }
      .tag { background: #eef1ff; color: #2d3c99; border-radius: 999px; padding: 4px 10px; font-size: 0.8rem; }
      .fullview { display: grid; grid-template-columns: 260px 1fr; gap: 24px; }
      @media (max-width: 720px) { .fullview { grid-template-columns: 1fr; } }
      .meta-panel { background: #f0f2f8; border-radius: 12px; padding: 16px; height: fit-content; }
      .meta-panel dt { font-size: 0.75rem; color: #61657a; margin-top: 10px; margin-bottom: 2px; }
      .meta-panel dd { margin: 0; font-size: 0.9rem; word-break: break-all; }
      .content-panel { background: #fff; border-radius: 12px; box-shadow: 0 2px 10px rgba(17,24,39,0.08); padding: 20px; }
      .tabs { display: flex; gap: 4px; margin-bottom: 16px; border-bottom: 1px solid #e6e8f2; }
      .tabs button { background: none; color: #61657a; border: 0; padding: 10px 14px; cursor: pointer; font-size: 0.9rem; border-bottom: 2px solid transparent; margin-bottom: -1px; }
      .tabs button.active { color: #3f5efb; border-bottom-color: #3f5efb; font-weight: 500; }
      .tab-body { white-space: pre-wrap; word-break: break-word; line-height: 1.6; min-height: 120px; }
      .back-link { display: inline-block; color: #3f5efb; text-decoration: none; margin-bottom: 16px; font-size: 0.9rem; }
      .back-link:hover { text-decoration: underline; }
      .btn-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      button.btn-danger { background: #dc3545; }
      button.btn-danger:hover { background: #c82333; }
      button.btn-outline { background: #fff; color: #3f5efb; border: 1px solid #3f5efb; }
      button.btn-outline:hover { background: #f8f9ff; }
      .tag-filter { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; margin-bottom: 12px; }
      .tag-filter .tag { cursor: pointer; }
      .tag-filter .tag.active { background: #3f5efb; color: #fff; }
      .note-actions { margin-top: 8px; display: flex; gap: 8px; }
      .tag-edit-row { display: flex; align-items: center; gap: 4px; flex-wrap: wrap; }
      .tag-edit-row .tag { display: inline-flex; align-items: center; gap: 4px; }
      .tag-edit-row .tag .tag-remove { background: none; color: #61657a; padding: 0 4px; font-size: 1rem; line-height: 1; cursor: pointer; border: 0; }
      .tag-edit-row .tag .tag-remove:hover { color: #dc3545; }
      .tag-add-form { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-top: 8px; }
      .tag-add-form input { flex: 1; min-width: 100px; }
      .social-embed-panel { margin-top: 16px; border-top: 1px solid #e6e8f2; padding-top: 16px; }
      .social-embed-panel h3 { margin: 0 0 10px; font-size: 1rem; }
      .embed-section + .embed-section { margin-top: 16px; }
      .embed-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
      .embed-controls { display: flex; gap: 6px; }
      .embed-controls button { padding: 6px 10px; font-size: 0.8rem; }
      .embed-track {
        display: flex;
        gap: 12px;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        scroll-padding-left: 2px;
        -webkit-overflow-scrolling: touch;
        touch-action: pan-x;
        padding-bottom: 6px;
      }
      .embed-item {
        flex: 0 0 min(100%, 560px);
        scroll-snap-align: start;
        border: 1px solid #e6e8f2;
        border-radius: 10px;
        background: #fafbff;
        padding: 10px;
      }
      .embed-link { margin-top: 8px; font-size: 0.8rem; word-break: break-all; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      const INSTAGRAM_EMBED_SCRIPT = "https://www.instagram.com/embed.js";
      const THREADS_EMBED_SCRIPT = "https://www.threads.net/embed.js";
      const KIND_FILTERS = [
        { id: "", label: "전체" },
        { id: "plain_text", label: "평문" },
        { id: "youtube", label: "유튜브" },
        { id: "instagram_post", label: "인스타" },
        { id: "instagram_reel", label: "릴스" },
        { id: "threads", label: "스레드" },
        { id: "other_link", label: "기타" },
      ];
      const KIND_LABEL_MAP = {
        plain_text: "평문",
        youtube: "유튜브",
        instagram_post: "인스타",
        instagram_reel: "릴스",
        threads: "스레드",
        other_link: "기타",
      };

      const scriptPromiseMap = new Map();

      function ensureScript(src) {
        if (scriptPromiseMap.has(src)) return scriptPromiseMap.get(src);
        const promise = new Promise((resolve, reject) => {
          const existing = document.querySelector(`script[data-embed-script="${src}"]`);
          if (existing) {
            if (existing.dataset.ready === "true") {
              resolve();
              return;
            }
            existing.addEventListener("load", () => resolve(), { once: true });
            existing.addEventListener("error", () => reject(new Error("스크립트를 불러오지 못했습니다.")), { once: true });
            return;
          }
          const script = document.createElement("script");
          script.async = true;
          script.src = src;
          script.dataset.embedScript = src;
          script.addEventListener("load", () => {
            script.dataset.ready = "true";
            resolve();
          }, { once: true });
          script.addEventListener("error", () => reject(new Error("스크립트를 불러오지 못했습니다.")), { once: true });
          document.body.appendChild(script);
        });
        scriptPromiseMap.set(src, promise);
        return promise;
      }

      function normalizeUrl(raw) {
        if (!raw || typeof raw !== "string") return null;
        try {
          const url = new URL(raw.trim());
          return url.toString();
        } catch (_) {
          return null;
        }
      }

      function detectSocialType(raw) {
        const normalized = normalizeUrl(raw);
        if (!normalized) return null;
        const parsed = new URL(normalized);
        const host = parsed.hostname.toLowerCase();
        if (host.endsWith("instagram.com") || host === "instagr.am") {
          if (parsed.pathname.includes("/p/") || parsed.pathname.includes("/reel/") || parsed.pathname.includes("/tv/")) {
            return { type: "instagram", url: normalized };
          }
          return null;
        }
        if (host.endsWith("threads.net")) {
          if (parsed.pathname.includes("/post/")) {
            return { type: "threads", url: normalized };
          }
        }
        return null;
      }

      function extractSocialLinks(note) {
        const sources = [note?.sourceUrl, note?.contentFull, note?.summaryLong, note?.summaryShort].filter(Boolean).join("\n");
        const matches = sources.match(/https?:\/\/[^\s"'<>]+/g) || [];
        const unique = new Set();
        if (note?.sourceUrl) unique.add(note.sourceUrl);
        matches.forEach((m) => unique.add(m));

        const instagram = [];
        const threads = [];

        Array.from(unique).forEach((url) => {
          const parsed = detectSocialType(url);
          if (!parsed) return;
          if (parsed.type === "instagram" && !instagram.includes(parsed.url)) instagram.push(parsed.url);
          if (parsed.type === "threads" && !threads.includes(parsed.url)) threads.push(parsed.url);
        });

        return { instagram, threads };
      }

      function SwipeableEmbedStrip({ title, links, kind, trackRef }) {
        if (!links.length) return null;

        const scrollTrack = (direction) => {
          const node = trackRef.current;
          if (!node) return;
          const amount = Math.max(node.clientWidth * 0.9, 280);
          node.scrollBy({ left: direction * amount, behavior: "smooth" });
        };

        return (
          <section className="embed-section">
            <div className="embed-header">
              <h3>{title}</h3>
              {links.length > 1 ? (
                <div className="embed-controls">
                  <button type="button" className="btn-outline" onClick={() => scrollTrack(-1)}>이전</button>
                  <button type="button" className="btn-outline" onClick={() => scrollTrack(1)}>다음</button>
                </div>
              ) : null}
            </div>
            <div className="embed-track" ref={trackRef} aria-label={title}>
              {links.map((url) => (
                <article className="embed-item" key={`${kind}-${url}`}>
                  {kind === "instagram" ? (
                    <blockquote className="instagram-media" data-instgrm-permalink={url} data-instgrm-version="14" style={{ margin: 0, minWidth: 0 }}>
                      <a href={url} target="_blank" rel="noopener noreferrer">Instagram 콘텐츠 보기</a>
                    </blockquote>
                  ) : (
                    <blockquote className="threads-embed" data-threads-post-url={url} style={{ margin: 0, minWidth: 0 }}>
                      <a href={url} target="_blank" rel="noopener noreferrer">Threads 콘텐츠 보기</a>
                    </blockquote>
                  )}
                  <div className="embed-link">
                    <a href={url} target="_blank" rel="noopener noreferrer">{url}</a>
                  </div>
                </article>
              ))}
            </div>
          </section>
        );
      }

      function SocialEmbedViewer({ note }) {
        const { instagram, threads } = useMemo(() => extractSocialLinks(note), [note]);
        const instagramTrackRef = useRef(null);
        const threadsTrackRef = useRef(null);

        const processThreadsEmbeds = () => {
          const candidates = [
            window?.threads?.process,
            window?.threads?.Embeds?.process,
            window?.__threadsEmbed?.process,
            window?.__threadsEmbed?.load,
          ];
          for (const fn of candidates) {
            if (typeof fn === "function") {
              fn();
              return true;
            }
          }
          return false;
        };

        useEffect(() => {
          if (!instagram.length) return;
          ensureScript(INSTAGRAM_EMBED_SCRIPT)
            .then(() => {
              if (window.instgrm && window.instgrm.Embeds && typeof window.instgrm.Embeds.process === "function") {
                window.instgrm.Embeds.process();
              }
            })
            .catch(() => {});
        }, [instagram]);

        useEffect(() => {
          if (!threads.length) return;
          ensureScript(THREADS_EMBED_SCRIPT)
            .then(() => {
              if (processThreadsEmbeds()) return;
              const refreshScript = document.createElement("script");
              refreshScript.async = true;
              refreshScript.src = THREADS_EMBED_SCRIPT;
              const cleanup = () => refreshScript.remove();
              refreshScript.addEventListener("load", cleanup, { once: true });
              refreshScript.addEventListener("error", cleanup, { once: true });
              document.body.appendChild(refreshScript);
            })
            .catch(() => {});
        }, [threads]);

        if (!instagram.length && !threads.length) return null;

        return (
          <section className="social-embed-panel">
            <h2 style={{ marginTop: 0 }}>연결된 소셜 페이지</h2>
            <p className="muted" style={{ marginTop: 0 }}>모바일에서는 좌우 스와이프로 카드/스레드를 넘길 수 있습니다.</p>
            <SwipeableEmbedStrip title="Instagram 카드" links={instagram} kind="instagram" trackRef={instagramTrackRef} />
            <SwipeableEmbedStrip title="Threads 스레드" links={threads} kind="threads" trackRef={threadsTrackRef} />
          </section>
        );
      }

      function parseRoute() {
        const hash = (window.location.hash || "#/").slice(1);
        const parts = hash.split("/").filter(Boolean);
        if (parts[0] === "notes" && parts[1]) {
          const id = parseInt(parts[1], 10);
          return { page: "note", noteId: isNaN(id) ? null : id };
        }
        return { page: "list", noteId: null };
      }

      function getKindLabel(kindId) {
        return KIND_LABEL_MAP[kindId] || kindId;
      }

      function NoteFullView({ noteId, onDeleted }) {
        const [note, setNote] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [tab, setTab] = useState("short");
        const [deleting, setDeleting] = useState(false);
        const [newTagName, setNewTagName] = useState("");
        const [newTagType, setNewTagType] = useState("tag");
        const [tagSaving, setTagSaving] = useState(false);
        const [editingTag, setEditingTag] = useState(null);
        const [editTagValue, setEditTagValue] = useState("");
        const [tagMessage, setTagMessage] = useState("");

        useEffect(() => {
          let cancelled = false;
          setLoading(true);
          setError(null);
          fetch(`/api/v1/notes/${noteId}`)
            .then((res) => {
              if (!res.ok) throw new Error("노트를 찾을 수 없습니다.");
              return res.json();
            })
            .then((data) => { if (!cancelled) setNote(data); })
            .catch((e) => { if (!cancelled) setError(e.message); })
            .finally(() => { if (!cancelled) setLoading(false); });
          return () => { cancelled = true; };
        }, [noteId]);

        const buildTagsPayload = () => {
          const tags = (note?.tags || []).map((t) => ({ name: t.name, type: "tag" }));
          const hashtags = (note?.hashtags || []).map((h) => ({ name: h.name, type: "hashtag" }));
          return [...tags, ...hashtags];
        };

        const patchTags = async (payload) => {
          setTagSaving(true);
          setTagMessage("");
          try {
            const res = await fetch(`/api/v1/notes/${noteId}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ tags: payload }),
            });
            if (!res.ok) throw new Error("저장 실패");
            const data = await res.json();
            setNote(data);
          } catch (e) {
            setTagMessage(e.message || "태그 저장에 실패했습니다.");
          } finally {
            setTagSaving(false);
          }
        };

        const handleRemoveTag = (type, name) => {
          const current = buildTagsPayload().filter((t) => !(t.type === type && t.name === name));
          patchTags(current);
        };

        const handleAddTag = () => {
          setTagMessage("");
          const name = (newTagName || "").trim();
          if (!name) return;
          const current = buildTagsPayload();
          if (current.some((t) => t.type === newTagType && t.name === name)) {
            setTagMessage("이미 같은 이름의 태그가 있습니다.");
            return;
          }
          setNewTagName("");
          patchTags([...current, { name, type: newTagType }]);
        };

        const handleStartEditTag = (type, name) => {
          setEditingTag({ type, name });
          setEditTagValue(name);
        };

        const handleSaveEditTag = () => {
          const newName = (editTagValue || "").trim();
          if (!newName || !editingTag) return;
          const current = buildTagsPayload();
          const updated = current.map((t) =>
            t.type === editingTag.type && t.name === editingTag.name ? { ...t, name: newName } : t
          );
          setEditingTag(null);
          setEditTagValue("");
          patchTags(updated);
        };

        const handleDelete = async () => {
          if (!window.confirm("이 메모를 삭제할까요?")) return;
          setDeleting(true);
          try {
            const res = await fetch(`/api/v1/notes/${noteId}`, { method: "DELETE" });
            if (!res.ok) throw new Error("삭제 실패");
            if (typeof onDeleted === "function") onDeleted();
            window.location.hash = "#/";
          } catch (e) {
            setError(e.message || "삭제에 실패했습니다.");
          } finally {
            setDeleting(false);
          }
        };

        if (loading) return <div className="container"><p>불러오는 중...</p></div>;
        if (error || !note) return <div className="container"><a href="#/" className="back-link">목록으로</a><p className="muted">{error || "노트를 찾을 수 없습니다."}</p></div>;

        const tabs = [
          { id: "short", label: "요약(짧게)", text: note.summaryShort || "없음" },
          { id: "long", label: "요약(표준)", text: note.summaryLong || "없음" },
          { id: "full", label: "본문 전체", text: note.contentFull || "없음" },
          { id: "memo", label: "원문 메모", text: note.errorMessage || "없음" },
        ];
        const activeContent = tabs.find((t) => t.id === tab)?.text ?? "";
        const allTagItems = [...(note.tags || []).map((t) => ({ ...t, type: "tag" })), ...(note.hashtags || []).map((h) => ({ ...h, type: "hashtag" }))];

        return (
          <div className="container">
            <div className="btn-group" style={{ marginBottom: 16 }}>
              <a href="#/" className="back-link">목록으로</a>
              <button type="button" className="btn-danger" disabled={deleting} onClick={handleDelete}>
                {deleting ? "삭제 중..." : "메모 삭제"}
              </button>
            </div>
            <div className="fullview">
              <aside className="meta-panel">
                <dl>
                  <dt>원본 URL</dt>
                  <dd><a href={note.sourceUrl} target="_blank" rel="noopener noreferrer">{note.sourceUrl}</a></dd>
                  <dt>수집 시간</dt>
                  <dd>{note.createdAt ? new Date(note.createdAt).toLocaleString("ko-KR") : "-"}</dd>
                  <dt>카테고리</dt>
                  <dd>{note.category?.name ?? "-"}</dd>
                  <dt>태그 / 해시태그</dt>
                  <dd>
                    <div className="tag-edit-row">
                      {allTagItems.map((t) => (
                        <span className="tag" key={`${t.type}-${t.name}`}>
                          {editingTag && editingTag.type === t.type && editingTag.name === t.name ? (
                            <input
                              type="text"
                              value={editTagValue}
                              onChange={(e) => setEditTagValue(e.target.value)}
                              onBlur={handleSaveEditTag}
                              onKeyDown={(e) => { if (e.key === "Enter") handleSaveEditTag(); if (e.key === "Escape") { setEditingTag(null); setEditTagValue(""); } }}
                              autoFocus
                              style={{ width: 80, padding: "2px 6px", fontSize: "0.8rem" }}
                            />
                          ) : (
                            <>
                              <span role="button" tabIndex={0} onClick={() => handleStartEditTag(t.type, t.name)} onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); handleStartEditTag(t.type, t.name); } }}>#{t.name}</span>
                              <button type="button" className="tag-remove" aria-label="삭제" onClick={(e) => { e.stopPropagation(); handleRemoveTag(t.type, t.name); }}>×</button>
                            </>
                          )}
                        </span>
                      ))}
                    </div>
                    <div className="tag-add-form">
                      <input
                        type="text"
                        placeholder="새 태그 이름"
                        value={newTagName}
                        onChange={(e) => setNewTagName(e.target.value)}
                        onKeyDown={(e) => { if (e.key === "Enter") { e.preventDefault(); handleAddTag(); } }}
                      />
                      <select value={newTagType} onChange={(e) => setNewTagType(e.target.value)} style={{ padding: "6px 8px" }}>
                        <option value="tag">태그</option>
                        <option value="hashtag">해시태그</option>
                      </select>
                      <button type="button" disabled={tagSaving} onClick={handleAddTag}>{tagSaving ? "저장 중..." : "추가"}</button>
                    </div>
                    {tagMessage ? <p className="muted" style={{ marginTop: 4, marginBottom: 0 }}>{tagMessage}</p> : null}
                    {allTagItems.length === 0 && !tagSaving && !tagMessage ? <span className="muted">태그를 추가하거나 클릭해서 이름을 수정할 수 있습니다.</span> : null}
                  </dd>
                </dl>
              </aside>
              <div className="content-panel">
                <h2 style={{ marginTop: 0 }}>{note.aiTitle || "제목 없음"}</h2>
                <div className="tabs">
                  {tabs.map((t) => (
                    <button key={t.id} type="button" className={tab === t.id ? "active" : ""} onClick={() => setTab(t.id)}>{t.label}</button>
                  ))}
                </div>
                <div className="tab-body">{activeContent}</div>
                <SocialEmbedViewer note={note} />
              </div>
            </div>
          </div>
        );
      }

      function App() {
        const [route, setRoute] = useState(parseRoute);
        const [urlText, setUrlText] = useState("");
        const [notes, setNotes] = useState([]);
        const [tags, setTags] = useState([]);
        const [selectedTag, setSelectedTag] = useState("");
        const [selectedKind, setSelectedKind] = useState("");
        const [kindCounts, setKindCounts] = useState({});
        const [totalKindNotes, setTotalKindNotes] = useState(null);
        const [loading, setLoading] = useState(false);
        const [submitting, setSubmitting] = useState(false);
        const [message, setMessage] = useState("");
        const [importKtFile, setImportKtFile] = useState(null);
        const [importKtSubmitting, setImportKtSubmitting] = useState(false);
        const [importKtMessage, setImportKtMessage] = useState("");
        const [resetting, setResetting] = useState(false);

        useEffect(() => {
          const handler = () => setRoute(parseRoute());
          window.addEventListener("hashchange", handler);
          return () => window.removeEventListener("hashchange", handler);
        }, []);

        const fetchNotes = async () => {
          setLoading(true);
          try {
            const params = new URLSearchParams({ page: "1", size: "200" });
            if (selectedTag) params.set("tag", selectedTag);
            if (selectedKind) params.set("kind", selectedKind);
            const response = await fetch("/api/v1/notes?" + params.toString());
            const data = await response.json();
            setNotes(data.items || []);
          } catch (err) {
            setMessage("노트 목록을 불러오지 못했습니다.");
          } finally {
            setLoading(false);
          }
        };

        const fetchTags = async () => {
          try {
            const response = await fetch("/api/v1/tags");
            const data = await response.json();
            setTags(data.items || []);
          } catch (_) {
            setTags([]);
          }
        };

        const fetchNoteKinds = async () => {
          try {
            const params = new URLSearchParams();
            if (selectedTag) params.set("tag", selectedTag);
            const query = params.toString();
            const response = await fetch("/api/v1/note-kinds" + (query ? `?${query}` : ""));
            if (!response.ok) throw new Error("kind_count_fetch_failed");
            const data = await response.json();
            const nextCounts = {};
            (data.items || []).forEach((item) => {
              if (!item || !item.kind) return;
              nextCounts[item.kind] = item.count || 0;
            });
            setKindCounts(nextCounts);
            setTotalKindNotes(typeof data.totalNotes === "number" ? data.totalNotes : null);
          } catch (_) {
            setKindCounts({});
            setTotalKindNotes(null);
          }
        };

        useEffect(() => {
          if (route.page === "list") {
            fetchNotes();
            fetchTags();
            fetchNoteKinds();
          }
        }, [route.page, selectedTag, selectedKind]);

        const onSubmit = async (event) => {
          event.preventDefault();
          const urls = urlText.split("\n").map((item) => item.trim()).filter(Boolean);
          if (!urls.length) {
            setMessage("URL을 1개 이상 입력해주세요.");
            return;
          }
          setSubmitting(true);
          setMessage("");
          try {
            const response = await fetch("/api/v1/ingestions", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ urls }),
            });
            if (!response.ok) throw new Error();
            const data = await response.json();
            setMessage(`수집 요청 완료 (jobId: ${data.jobId})`);
            setUrlText("");
            fetchNotes();
          } catch (err) {
            setMessage("수집 요청에 실패했습니다.");
          } finally {
            setSubmitting(false);
          }
        };

        const onImportKakaotalk = async (event) => {
          event.preventDefault();
          if (!importKtFile) {
            setImportKtMessage("CSV 파일을 선택해주세요.");
            return;
          }
          setImportKtSubmitting(true);
          setImportKtMessage("");
          try {
            const formData = new FormData();
            formData.append("file", importKtFile);
            const response = await fetch("/api/v1/import/kakaotalk?skip_duplicates=true", {
              method: "POST",
              body: formData,
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.detail || "가져오기 실패");
            setImportKtMessage(`가져오기 완료: ${data.imported}건 등록, ${data.skipped}건 중복 스킵 (총 ${data.total}건)`);
            setImportKtFile(null);
            document.getElementById("kt-csv-input")?.reset?.();
            fetchNotes();
            fetchTags();
          } catch (err) {
            setImportKtMessage(err.message || "카카오톡 CSV 가져오기에 실패했습니다.");
          } finally {
            setImportKtSubmitting(false);
          }
        };

        const onResetAll = async () => {
          if (!window.confirm("전체 메모를 삭제합니다. 되돌릴 수 없습니다. 계속할까요?")) return;
          setResetting(true);
          setMessage("");
          try {
            const response = await fetch("/api/v1/notes?all=true", { method: "DELETE" });
            const data = await response.json();
            if (!response.ok) throw new Error(data.detail || "초기화 실패");
            setMessage(data.message || `${data.deleted}건 삭제되었습니다.`);
            setSelectedTag("");
            fetchNotes();
            fetchTags();
          } catch (err) {
            setMessage(err.message || "초기화에 실패했습니다.");
          } finally {
            setResetting(false);
          }
        };

        const onDeleteNote = async (e, noteId) => {
          e.preventDefault();
          e.stopPropagation();
          if (!window.confirm("이 메모를 삭제할까요?")) return;
          try {
            const res = await fetch(`/api/v1/notes/${noteId}`, { method: "DELETE" });
            if (!res.ok) throw new Error();
            fetchNotes();
            fetchTags();
          } catch (_) {
            setMessage("삭제에 실패했습니다.");
          }
        };

        if (route.page === "note" && route.noteId) {
          return <NoteFullView noteId={route.noteId} />;
        }

        return (
          <div className="container">
            <h1>Note Nomi</h1>
            <p className="muted">React 기반 임시 UI입니다. 추후 피그마 디자인 반영 전까지 빠르게 사용할 수 있어요.</p>
            <section className="card">
              <h2>카카오톡 나에게 보내기 가져오기</h2>
              <form id="kt-csv-input" onSubmit={onImportKakaotalk}>
                <input
                  type="file"
                  accept=".csv"
                  onChange={(e) => setImportKtFile(e.target.files?.[0] ?? null)}
                />
                <button type="submit" disabled={importKtSubmitting}>
                  {importKtSubmitting ? "가져오는 중..." : "CSV 메모로 등록"}
                </button>
              </form>
              {importKtMessage && <p className="muted">{importKtMessage}</p>}
            </section>
            <section className="card">
              <h2>URL 수집 요청</h2>
              <form onSubmit={onSubmit}>
                <textarea rows="4" placeholder="URL을 줄바꿈으로 여러 개 입력하세요" value={urlText} onChange={(event) => setUrlText(event.target.value)} />
                <button type="submit" disabled={submitting}>{submitting ? "요청 중..." : "수집 시작"}</button>
              </form>
              {message && <p className="muted">{message}</p>}
            </section>
            <section className="card">
              <div className="btn-group" style={{ justifyContent: "space-between", marginBottom: 12 }}>
                <h2 style={{ margin: 0 }}>최근 노트</h2>
                <button type="button" className="btn-danger" disabled={resetting || notes.length === 0} onClick={onResetAll}>
                  {resetting ? "초기화 중..." : "전체 초기화"}
                </button>
              </div>
              <div className="tag-filter">
                <span className="muted">유형별 보기:</span>
                {KIND_FILTERS.map((kind) => {
                  const isAll = kind.id === "";
                  const count = isAll ? totalKindNotes : kindCounts[kind.id];
                  const hasCount = typeof count === "number";
                  return (
                    <span
                      className={"tag" + (selectedKind === kind.id ? " active" : "")}
                      key={kind.id || "all"}
                      onClick={() => setSelectedKind(kind.id)}
                      role="button"
                      tabIndex={0}
                      onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); setSelectedKind(kind.id); } }}
                    >{kind.label}{hasCount ? ` (${count})` : ""}</span>
                  );
                })}
              </div>
              <div className="tag-filter">
                <span className="muted">태그별 보기:</span>
                <span
                  className={"tag" + (selectedTag === "" ? " active" : "")}
                  onClick={() => setSelectedTag("")}
                  role="button"
                  tabIndex={0}
                  onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); setSelectedTag(""); } }}
                >전체</span>
                {tags.map((t) => (
                  <span
                    className={"tag" + (selectedTag === t.name ? " active" : "")}
                    key={t.name}
                    onClick={() => setSelectedTag(t.name)}
                    role="button"
                    tabIndex={0}
                    onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); setSelectedTag(t.name); } }}
                  >#{t.name} ({t.count})</span>
                ))}
                {tags.length === 0 && !loading ? <span className="muted">태그 없음</span> : null}
              </div>
              {loading ? <p>불러오는 중...</p> : notes.length === 0 ? <p className="muted">{selectedTag || selectedKind ? "해당 조건의 메모가 없습니다." : "아직 수집된 노트가 없습니다."}</p> : notes.map((note) => {
                const noteTags = [...(note.tags || []), ...(note.hashtags || [])];
                const noteKinds = (note.kinds || []).filter(Boolean);
                return (
                  <article
                    className="note"
                    key={note.id}
                    role="button"
                    tabIndex={0}
                    onClick={() => { window.location.hash = `#/notes/${note.id}`; }}
                    onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); window.location.hash = `#/notes/${note.id}`; } }}
                  >
                    <h3>{note.aiTitle || "제목 없음"}</h3>
                    <p className="muted">{note.sourceUrl}</p>
                    <p>{note.summaryShort || "요약이 아직 없습니다."}</p>
                    <div className="tags">
                      {noteKinds.map((kind) => <span className="tag" key={`${note.id}-kind-${kind}`}>{getKindLabel(kind)}</span>)}
                      {note.category?.name ? <span className="tag">#{note.category.name}</span> : null}
                      {noteTags.map((tag) => <span className="tag" key={`${note.id}-${tag.type}-${tag.name}`}>#{tag.name}</span>)}
                    </div>
                    <div className="note-actions">
                      <button type="button" className="btn-outline" style={{ fontSize: "0.8rem", padding: "4px 10px" }} onClick={(e) => onDeleteNote(e, note.id)}>삭제</button>
                    </div>
                  </article>
                );
              })}
            </section>
          </div>
        );
      }
      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
